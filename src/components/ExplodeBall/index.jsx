/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.15 public/models/ExplodingBalls.glb 
*/
import React, { useEffect, useRef } from 'react'
import * as THREE from 'three'
import { useGLTF, useTexture, useAnimations } from '@react-three/drei'
import { useFrame, extend } from '@react-three/fiber'
import { shaderMaterial, useFBO } from "@react-three/drei";//创建自定义着色器材质和渲染目标。
import { Leva, useControls } from "leva";
import { EffectComposer, Bloom } from '@react-three/postprocessing'

// 闪电噪波纹理
export const ShMaterial = shaderMaterial({
    uTime: 0,
    transparent: true,
    side: THREE.DoubleSide,
    depthTest: true,      // 启用深度测试
    depthWrite: false,    // 禁用深度写入（确保后面的内容不被遮挡）
    depthFunc: THREE.Lequal, // 确保按深度进行比较

    uColor: new THREE.Color("skyblue"),
    uNoiseTexture: new THREE.Texture()
},
/*glsl*/`
 varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`,

/*glsl*/`
    varying vec2 vUv;
    uniform float uTime;
    uniform vec3 uColor;
    uniform sampler2D uNoiseTexture;
    void main() {

        // 移动纹理的 UV 坐标（在 y 轴方向上根据 uTime 偏移）
    vec2 movingUV = vUv;
    movingUV.y -= uTime; // 控制移动速度
    // 让纹理在 y 轴上循环移动，通过 mod 限制坐标范围在 [0, 1]
    movingUV.y = mod(movingUV.y, 1.0);
    // 采样噪声纹理
    vec4 texColor = texture2D(uNoiseTexture, movingUV);
     // 计算黑白过渡区域，用于检测边界
     float edge = smoothstep(0.2, 0.5, texColor.r);

    // 基于边界的亮度调整，让亮区渐变为更亮的 uColor
    vec3 brightColor = uColor * 2.0; // 适当增加亮度

    // 根据边界的结果，选择不同的颜色：亮色或原色
    vec3 finalColor = mix(uColor, brightColor, edge);

    // 应用 alpha 通道，让黑色区域变透明
    float alpha = texColor.r > 0.2 ? 1.0 : 0.0;

    // 输出最终颜色
    gl_FragColor = vec4(finalColor, alpha);

        
    }
`)
export const ShadeMaterial = shaderMaterial({
    uTime: 0,
    transparent: true,
    side: THREE.DoubleSide,
    depthTest: true,      // 启用深度测试
    depthWrite: false,    // 禁用深度写入（确保后面的内容不被遮挡）
    depthFunc: THREE.Lequal, // 确保按深度进行比较
    uColor: new THREE.Color("skyblue"),
    uColor2: new THREE.Color("skyblue"),

    speed: 0.5, // 控制噪声速度
    amp_start: 0.5, // 开始振幅
    amp_coeff: 0.5, // 振幅系数
    freq_coeff: 2.0, // 频率系数
    octave_count: 10, // 噪声迭代次数
    effect_color: new THREE.Color(0.2, 0.3, 0.8)// 闪电颜色
},
/*glsl*/`
 varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`,

/*glsl*/`
    varying vec2 vUv;
    uniform float uTime;
    uniform vec3 uColor;

    uniform vec3 effect_color;
    uniform int octave_count;
    uniform float amp_start;
    uniform float amp_coeff;
    uniform float freq_coeff;
    uniform float speed;
    // Hash 函数
    float hash12(vec2 x) {
        return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);
    }

    vec2 hash22(vec2 uv) {
        uv = vec2(dot(uv, vec2(127.1,311.7)),
                dot(uv, vec2(269.5,183.3)));
        return 2.0 * fract(sin(uv) * 43758.5453123) - 1.0;
    }

    // 噪声函数
    float noise(vec2 uv) {
        vec2 iuv = floor(uv);
        vec2 fuv = fract(uv);
        vec2 blur = smoothstep(0.0, 1.0, fuv);
        return mix(mix(dot(hash22(iuv + vec2(0.0,0.0)), fuv - vec2(0.0,0.0)),
                    dot(hash22(iuv + vec2(1.0,0.0)), fuv - vec2(1.0,0.0)), blur.x),
                mix(dot(hash22(iuv + vec2(0.0,1.0)), fuv - vec2(0.0,1.0)),
                    dot(hash22(iuv + vec2(1.0,1.0)), fuv - vec2(1.0,1.0)), blur.x), blur.y) + 0.5;
    }
    // Fractal Brownian Motion (fbm) 函数
    float fbm(vec2 uv, int octaves) {
        float value = 0.0;
        float amplitude = amp_start;
        for (int i = 0; i < octaves; i++) {
            value += amplitude * noise(uv);
            uv *= freq_coeff;
            amplitude *= amp_coeff;
        }
        return value;
    }
    void main() {
        // float len = 0.15; //设置为表示胶囊的半宽度
        // float falloff = 0.1; //边缘的平滑度
        // float p = mod(uTime * 0.25, 1.0); //时间驱动的偏移量
        // float alpha = smoothstep(len, len - falloff, abs(vUv.x - p));//计算当前片段的透明度 从白色渐变到透明
        // float width = smoothstep(len * 2.0, 0.0, abs(vUv.x - p)) * 0.5;//更宽的平滑

        // alpha *= smoothstep(width, width - 0.3, abs(vUv.y - 0.5));
        // alpha *= smoothstep(0.5, 0.3, abs(p - 0.5) * (1.0 + len));

        // // gl_FragColor = vec4(vec3(uColor),alpha);
        // gl_FragColor = vec4(vec3(0.0,0.0,0.0),1.0);

        vec2 uv = 2.0 * vUv - 1.0; // 将 UV 坐标映射到 [-1, 1] 范围
        uv += 2.0 * fbm(uv + uTime * speed, octave_count) - 1.0; // 添加基于时间的噪声
        float dist = abs(uv.x); // 计算距离
        vec3 color = uColor * mix(0.0, 0.05, hash12(vec2(uTime))) / dist; // 计算颜色
        
        // 计算颜色亮度，用于控制透明度
        float brightness = dot(color, vec3(0.299, 0.587, 0.114)); // 将颜色转换为亮度

        float alpha = smoothstep(0.1, 0.2, brightness);
       
        gl_FragColor = vec4(color, alpha); // 设置片段颜色

        
    }
`)

// 效果
export const AuraMaterial = shaderMaterial({
    uTime: 0,
    transparent: true,
    side: THREE.DoubleSide,
    depthTest: true,      // 启用深度测试
    depthWrite: false,    // 禁用深度写入（确保后面的内容不被遮挡）
    depthFunc: THREE.Lequal, // 确保按深度进行比较
    uColor: new THREE.Color("skyblue"),
},
/*glsl*/`
 varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`,

/*glsl*/`
    varying vec2 vUv;
    uniform float uTime;
    uniform vec3 uColor;

    void main() {
        float len = 0.25; // 设置为表示胶囊的半宽度 
        float falloff = 0.1; // 边缘的平滑度
        float p = mod(uTime * 0.25, 1.0); // 时间驱动的偏移量

        // 计算边缘的透明度
        float alpha = smoothstep(len, len - falloff, abs(vUv.x - p));

        // 计算边缘宽度
        float width = smoothstep(len * 2.0, 0.0, abs(vUv.x - p)) * 0.5;

        // 添加边缘的平滑过渡
        alpha *= smoothstep(width, width - 0.3, abs(vUv.y - 0.5));
        alpha *= smoothstep(0.5, 0.3, abs(p - 0.5) * (1.0 + len));

        // 计算中间区域的亮度
        vec3 middleColor = vec3(1.0); // 中间部分的发亮颜色（白色）
        
        // 设置最终颜色
        vec3 color = mix(vec3(uColor), middleColor, alpha); // 根据 alpha 混合颜色

        gl_FragColor = vec4(color, alpha); // 输出颜色
        
    }
`)


extend({ ShMaterial, ShadeMaterial, AuraMaterial })

export default function ExplodingBall(props) {
    const group = useRef()

    const { nodes, animations, scene } = useGLTF('models/ExplodingBalls.glb')

    const { actions } = useAnimations(animations, group)

    const { color1, color2, color3, color4 } = useControls({
        color1: '#fff4a5',
        color2: '#ffd85c',
        color3: '#ff8900',
        color4: '#b2d3ff'
    })
    const texture = useTexture('/textures/elec2.png');

    const shRef = useRef()
    const shaderRef = useRef()
    const shaderRef2 = useRef()
    const shaderRef3 = useRef()
    const auraRef4 = useRef()
    const auraRef5 = useRef()
    const plantRef = useRef()
    const ref3 = useRef()
    useFrame(({ clock }) => {
        shRef.current.uniforms.uTime.value = clock.getElapsedTime() * 2
        shaderRef2.current.uniforms.uTime.value = clock.getElapsedTime() * 2
        shaderRef3.current.uniforms.uTime.value = clock.getElapsedTime()
        auraRef5.current.uniforms.uTime.value = clock.getElapsedTime() * 5
        //  plantRef.current.uniforms.uTime.value = clock.getElapsedTime()
    })

    const { intensity, radius, levels } = useControls({
        intensity: { value: 1, min: 0, max: 1.5, step: 0.01 },
        radius: { value: 0.35, min: 0, max: 1, step: 0.01 },
        levels: { value: 7, min: 0, max: 8, step: 1 }
    })
    return (
        <>
            <EffectComposer>
                <Bloom luminanceThreshold={0} intensity={intensity} mipmapBlur radius={radius} levels={levels} />
            </EffectComposer>

            {/* <primitive object={scene} /> */}
            <group  {...props} dispose={null}>
                <ambientLight intensity={2} />
                <group name="Scene">
                    <group ref={group}>
                        <mesh
                            ref={ref3}
                            name="球体003" geometry={nodes.球体003.geometry} material={nodes.球体003.material}>
                            {/* <meshStandardMaterial color="red" emissive="yellow" emissiveIntensity={0.5} /> */}
                            <shMaterial ref={shRef} uColor={color1} uNoiseTexture={texture} />
                            {/* <transShaderMaterial ref={transRef} uColor={color2}/> */}

                        </mesh>
                        <mesh name="球体004" geometry={nodes.球体004.geometry} material={nodes.球体004.material}>
                            {/* <shadeMaterial ref={shaderRef} /> */}
                            {/* <auraMaterial ref={auraRef4} uColor={color3} /> */}
                            <shMaterial ref={shaderRef2} uColor={color2} uNoiseTexture={texture} />

                        </mesh>
                        <mesh name="球体005" geometry={nodes.球体005.geometry} material={nodes.球体005.material} >
                            {/* <auraMaterial ref={auraRef5} uColor={color2} /> */}
                            <shMaterial ref={shaderRef3} uColor={color3} uNoiseTexture={texture} />

                        </mesh>
                    </group>

                    <mesh name="环体001" geometry={nodes.环体001.geometry} material={nodes.环体001.material} >
                        {/* <meshStandardMaterial color="blue" emissive="blue" emissiveIntensity={0.5} /> */}
                        {/* <shadeMaterial ref={shaderRef} uColor={color1} /> */}
                        <auraMaterial ref={auraRef5} uColor={color4} />
                    </mesh>
                    {/* 测试平面 */}
                    {/* <mesh>
                        <planeGeometry args={[5, 5]} />
                        <auraMaterial ref={plantRef} uColor={color4} />
                    </mesh> */}

                </group>
            </group >
        </>
    )
}
useGLTF.preload('models/ExplodingBalls.glb')

